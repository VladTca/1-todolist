import React, {useState} from 'react';
import './App.css';
import {TaskList} from "./Site/TaskList";
import {MainTitle} from "./Site/MainTitle";
import {v1} from "uuid";

export type TaskType = {
    id: string
    task: string
    isDone: boolean
}

export type FilterValuesType = 'all' | 'need' | 'done'

function App() {

// Данные---------------------------------------------------------------------------------------

    const description = 'A shopping list is a tool that helps to organize and simplify the process of buying goods. It can be used for a variety of purposes, including daily shopping, holiday planning, travel, and more.'

    const [shoppingList, setShoppingList] = useState([
        {id: v1(), task: 'Shoes', isDone: false},
        {id: v1(), task: 'Tee shirt', isDone: false},
        {id: v1(), task: 'Sunglasses', isDone: true}
    ])


    // const [petsTasks, setPetsTasks]=useState([
    //     {id: v1(), task: "Trim the cat's claws", isDone: false},
    //     {id: v1(), task: 'Groomer for the dog', isDone: false},
    //     {id: v1(), task: 'Clean the carrier', isDone: true},
    //     {id: v1(), task: 'Buy diapers', isDone: true}
    // ])


// Удаление таски---------------------------------------------------------------------------------------

    const deleteTask = (taskId: string) => {
        const filteredTasks = shoppingList.filter(el => {
            return el.id !== taskId
        })
        setShoppingList(filteredTasks)
    }

// Фильтрация тасок по кнопке---------------------------------------------------------------------------------------

    const [filter, setFilter] = useState<FilterValuesType>('all')

    const changeFilter = (filter:FilterValuesType)=> {
        setFilter(filter)
    }

    let tasksForShoppingList = shoppingList

    if (filter === 'need') {
        tasksForShoppingList = shoppingList.filter(task => !task.isDone)
    }

    if (filter === 'done') {
        tasksForShoppingList = shoppingList.filter(task => task.isDone)
    }

// Добавление таски---------------------------------------------------------------------------------------

    const addTask = (task: string) => {
        const newTask = {
            id: v1(),
            task,
            isDone: false,
        }
        const newTasks = [newTask, ...shoppingList]
        setShoppingList(newTasks)
    }

// Изменение статуса таски---------------------------------------------------------------------------------------


    const changeTaskStatus = (taskId: string, taskStatus: boolean) => {
        // const task = shoppingList.find(t => t.id === taskId)
        // if (task) {
        //     task.isDone = taskStatus
        //     setShoppingList([...shoppingList])
        // такой вариант работает, но лучше мапить}
        //Метод find возвращает первый элемент, который удовлетворяет условию, указанному в передаваемой функции. Он не изменяет исходный массив, а возвращает только этот элемент. Если вы измените возвращенный элемент, вы фактически измените исходный массив, что нарушает принципы иммутабельности в React.
        // С другой стороны, метод map создает новый массив, применяя указанную функцию к каждому элементу исходного массива. Он не изменяет исходный массив. Это соответствует принципам иммутабельности в React и является предпочтительным способом изменения состояний.
        // В вашем случае, когда вы хотите обновить статус задачи, вы создаете новый массив с помощью метода map, в котором все объекты остаются неизменными, кроме того, у которого id совпадает с taskId. Этот объект заменяется новым объектом, у которого все свойства идентичны исходному, за исключением isDone, значение которого устанавливается в taskStatus.
        // Таким образом, использование map вместо find в этом случае позволяет вам следовать принципам иммутабельности и правильно обновлять состояние в React.
        const newState = shoppingList.map(t => (t.id == taskId ? { ...t, isDone: taskStatus } : t))

        setShoppingList(newState)
    }

    return (
        <div>
            {/* <Example/> */}
            <MainTitle
                className={"title"}
                title={"Preparing for vacation"}
            />
            <div className='App'>
                <TaskList
                    list={tasksForShoppingList}
                    img={'/shopping.png'} title={'Shopping list'}
                    description={description}
                    deleteTask={deleteTask}
                    changeFilter={changeFilter}
                    addTask={addTask}
                    changeTaskStatus={changeTaskStatus}
                />
                {/*<TaskList list={petsTasks} img={'/dog.png'} title={'Pets'} description={description}/>*/}
            </div>
        </div>
    );
}

export default App;






// Теория---------------------------------------------------------------------------------------

//## Преимущества TypeScript
// 1. Тайпскрипт - это суперсет JavaScript, который добавляет статическую типизацию и другие функции, которые помогают делать код более надежным и легким для чтения и поддержки. Вот некоторые из преимуществ использования TypeScript:
// 2. Статическая типизация: Это одно из главных преимуществ TypeScript. Статическая типизация позволяет программистам заранее знать, какие типы данных они работают, что помогает предотвратить многие общие ошибки, которые могут возникнуть при работе с JavaScript.
// 3. Поддержка последних функций JavaScript: TypeScript поддерживает новейшие функции и синтаксис JavaScript, такие как классы, модули и стрелочные функции, что делает его идеальным выбором для современных проектов.
// 4. Инструменты разработки: TypeScript имеет отличную интеграцию с большинством современных инструментов разработки, таких как Visual Studio Code, что обеспечивает улучшенную подсветку синтаксиса, автозаполнение и даже автоматическую проверку типов в реальном времени.
// 5. Более легкий рефакторинг: Благодаря статической типизации, TypeScript делает рефакторинг кода более безопасным и эффективным, поскольку он может предупреждать вас о потенциальных проблемах, которые могут возникнуть при изменении типов данных.
// 6. Документация и сообщество: TypeScript имеет обширную документацию и активное сообщество разработчиков, которые могут помочь вам решить любые проблемы, с которыми вы можете столкнуться.
//
// В общем, TypeScript может сделать ваш код более надежным, понятным и поддерживаемым, что делает его отличным выбором для больших и сложных проектов.

// useState-это функция, предоставляющая возможность добавлять состояние (state) в функциональные компоненты.
// Тип данных, возвращаемый useState, всегда является массивом, где первый элемент содержит текущее значение состояния (может принимать в себя, как примитивы, так и объекты, массивы, функции- это позволяет вычислять начальное состояние с использованием сложной логики или на основе предыдущего состояния), а второй элемент - функцию для его обновления. При обновлении состояния с помощью этой функции React перерисовывает компонент, чтобы отразить новое состояние.

//Коллбэк-функция – это функция, которую мы передаем в другую функцию в качестве аргумента с целью вызвать её позже.
// Давайте рассмотрим простой пример. Представьте, что у вас есть две функции: одна называется "готовить ужин", а другая - "есть ужин". Вы не можете начать есть ужин, пока не приготовите его. Так что вы передаете функцию "есть ужин" в функцию "готовить ужин" в качестве коллбэк-функции. Тогда функция "готовить ужин" может вызвать функцию "есть ужин" сразу после того, как ужин будет готов.
// В контексте программирования это позволяет нам контролировать порядок выполнения функций, особенно когда мы работаем с асинхронными операциями, такими как запросы к серверу или таймеры.

//Метод filter используется, когда вы хотите пройти по массиву и выбрать из него определенные элементы. Он создает новый массив, в который включает только те элементы, которые удовлетворяют определенному условию.
// Например, у вас есть массив чисел, и вы хотите получить только четные числа. Вы бы использовали filter для этого.
// Метод map, с другой стороны, используется, когда вы хотите пройти по массиву и что-то изменить в каждом элементе. Он создает новый массив, в котором каждый элемент является результатом применения функции к каждому элементу исходного массива.
// Например, у вас есть массив чисел, и вы хотите удвоить каждое число. Вы бы использовали map для этого.

//Метод map в JavaScript применяется к массивам и создает новый массив, преобразуя каждый элемент исходного массива с помощью функции, которую вы передаете в качестве аргумента.
//Важно отметить, что исходный массив не изменяется. Метод map всегда возвращает новый массив, а исходный массив остается неизменным. Это делает map очень полезным в функциональном программировании, где изменение исходных данных считается плохой практикой.
//Метод map часто используется в React для отображения списков элементов. Например, вы можете использовать map для преобразования массива объектов в массив React-компонентов.

//Библиотека uuid в JavaScript - это пакет, который позволяет генерировать уникальные идентификаторы, так называемые UUID (Universally Unique Identifier). UUID представляет собой строку из 36 символов, включающую цифры, буквы и дефисы. Пример UUID выглядит так: '123e4567-e89b-12d3-a456-426614174000'.
// UUID используются для обеспечения уникальности идентификаторов во всем мире, не зависимо от того, где и когда они были созданы. Это очень полезно, когда вам нужно обеспечить уникальность данных в распределенной системе или при создании уникальных идентификаторов для элементов в базе данных.
//Функция v1() возвращает нам строковую id. Выглядят сгенерированная id примерно вот так "7a0366c3-c1c7-11ee-a7e3-5d0dba702e70"

//В контексте JavaScript и веб-разработки, event - это объект, который генерируется в результате определенных действий пользователя или браузера. Это могут быть действия пользователя, такие как клики мышью, нажатия клавиш, наведение мыши, но также и события, связанные с загрузкой страницы, изменением размера окна и т.д.
// event содержит множество свойств и методов, которые позволяют получить детальную информацию о произошедшем событии.
// event.currentTarget - это свойство объекта event, которое всегда указывает на элемент, на котором в данный момент обрабатывается событие. Оно используется в ситуациях, когда одно и то же событие обрабатывается несколькими элементами из-за всплытия событий.
// Всплытие событий - это процесс, при котором событие, произошедшее на одном элементе, "всплывает" по иерархии DOM и может быть обработано другими элементами.

//Метод find в JavaScript используется для поиска первого элемента в массиве, который удовлетворяет условию, указанному в передаваемой функции. Если элемент не найден, то метод возвращает undefined.
//Метод find принимает функцию в качестве аргумента. Эта функция должна возвращать true или false для каждого элемента массива. Если функция возвращает true, то метод find немедленно прекращает поиск и возвращает текущий элемент. Если функция возвращает false для всех элементов, то метод find возвращает undefined.

//Метод trim в JavaScript используется для удаления пробелов с обоих концов строки. Он не влияет на значение исходной строки, а возвращает новую строку. Важно отметить, что этот метод удаляет не только пробелы, но и другие пробельные символы, такие как табуляция, перевод строки и т.д.
//